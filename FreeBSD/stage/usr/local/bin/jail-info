#!/usr/bin/env bash

#======================================================
#
#   Extract jail info from /etc/jail.conf files
#
#======================================================

#   Copyright (c) 2025 Jim Long, kraken-jim@github.com
#   
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions
#   are met:
#   1. Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#   2. Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#   
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
#   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
#   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#   SUCH DAMAGE.

set -e

usage () {

cat << \EOF
usage:

    jail-info [ --list | -l ] [ (jail_name) [ (jail_name) ... ] ]

        List defined jail names.  If one or more jail names are
        specified, print the name attribute for each jail_name that
        is known to jail(8).  If no jail_name is specified, print all
        jail names known to jail(8).  If at least one matching jail
        is found, return success.  If none of the jails can be found,
        return failure.  This can be used with the -n option (below)
        to test whether a jail is defined:

            for j in bogus1 $(jail-info -ln) bogus2; do
                jail-info -ln $j > /dev/null ||
                    echo "jail $j was not found"
            done

    jail-info [ (jail_name) | all ] [ param [ param ... ] ]

        Show the values of param(s) in the configuration for jail
        (jail_name).  If "all" is used as the jail name, show the
        specified params for all jails known to jail(8).  If no
        parameter names are specified, print all parameters for the
        specified jail(s).  Otherwise, print only the specified
        parameters.  If none of the parameters is defined, or if
        jail_name is not defined, return failure, else return
        success.

        If at least one of the parameters is defined in at least one
        of the jails, then those parameters which are not defined in
        any of the jails are printed as "--" in single-line mode
        (-n), or explicitly unset when -n is not used.  rest of the
        parameters are printed normally.  Be aware that messages to
        stderr may be intermingled with message to stdout, and it may
        be desirable to redirect them separately:

            # jail-info -n all devfs_ruleset name path 2>/dev/null
            -- 'aarch64' '/jail/aarch64'
            -- 'mailman2' '/jail/mailman2'
            -- 'puppet-test' '/jail/puppet-test'
            '7' 'rocky' '/jail/rocky'
            -- 'webwork2' '/jail/webwork2'

        In this example, we see that only the "rocky" jail has the 
        "devfs_ruleset" parameter defined.  The error messages that
        would have made that obvious were discarded by sending stdout
        to /dev/null.  For convenience, the -q option is provided to
        silence certain messages that would otherwise go to stderr:

            # jail-info -n all devfs_ruleset name path >/dev/null
            parameter "devfs_ruleset" is unset in jail aarch64
            parameter "devfs_ruleset" is unset in jail mailman2
            parameter "devfs_ruleset" is unset in jail puppet-test
            parameter "devfs_ruleset" is unset in jail webwork2

        Either way the result code is successful, because the parameter 
        was found in at least one jail.  Conversely, the case of:

            jail-info all foobar ; echo $?

        yields stderr of:

            parameter "foobar" is unset in jail aarch64
            parameter "foobar" is unset in jail mailman2
            parameter "foobar" is unset in jail puppet-test
            parameter "foobar" is unset in jail rocky
            parameter "foobar" is unset in jail webwork2

        and a result code of 1.  The stdout from that command is:

            unset foobar
            unset foobar
            unset foobar
            unset foobar
            unset foobar

        but still a result code of 1.  The intent is to differentiate
        (at least in verbose output mode) between a defined parameter
        with a null value versus an undefined parameter.  If we modify
        webwork2 to include the setting  devfs_ruleset = '';  then 
        jail-info would output the following:

            # jail-info -q all devfs_ruleset; echo $?
            unset devfs_ruleset
            unset devfs_ruleset
            unset devfs_ruleset
            devfs_ruleset='7'
            devfs_ruleset=''
            0

        Finally, jail-info will always iterate over jails in the order
        that jail(8) lists them.  So for example, if:

            # jail-info -l 
            name='aarch64'
            name='mailman2'
            name='puppet-test'
            name='rocky'
            name='webwork2'

        Then this command will list the jails in the above order:

            # jail-info -l webwork2 rocky aarch64
            name='aarch64'
            name='rocky'
            name='webwork2'

        As will:

            # jail-info all path
            path='/jail/aarch64'
            path='/jail/mailman2'
            path='/jail/puppet-test'
            path='/jail/rocky'
            path='/jail/webwork2'

    OPTIONS
        --help
        -h  Show this help message.

        --list
        -l  List jail names only.  If no jail names are provided,
            list all jails.  Otherwise, check each jail name
            provided, and if is known to jail(8), list that jail
            name.  If none of the jail names provided are known,
            return a failure result code.  Otherwise return
            success.

        -n  Do not show variable names.  Show values only, one line
            per jail.  For each jail, in sequence, the specified
            parameter values are printed with bash-style quoting,
            space-separated, in the order specified on the
            command line.  This option is useful for setting
            shell positional variables:

                jail-info -n all linux.osname name path |
                while IFS= read -r line; do 
                    eval set -- "${line}"
                    printf 'jail "%s" is running "%s", ' "$2" "$1"
                    printf 'jail root is "%s"\n' "$3"
                done

        --quiet
        -q  Omit warning messages that would normally go to stderr.

EOF

} # usage


while getopts "dhlnq-:" opt
do
    case "$opt" in
    d)
        debug=1
        ;;
    [?h])
        help=1
        ;;
    l)
        list=1
        ;;
    n)
        vals_only=1     # show values only, not variable names
        ;;
    q)
        quiet=1
        ;;
    -)
        opt="$OPTARG"
        case "$opt" in
        debug|list|quiet|help)
            eval "${opt}=1"
            ;;
        *)
            printf 'unknown option: %s\n' "$opt"
        esac
        ;;
    *)
        printf 'unknown option: %s\n' "$opt"
    esac
done

shift $(($OPTIND-1))



jail_info () {

# This requires a patched version of jail(8) from 
# https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=287615  to
# generate NUL-delimited fields, with an empty NUL line between jails.

# This function dumps all jails defined in jail.conf(5) to stdout.
# If global variable  $quiet  is set, then  stderr  will be suppressed.

local q     # so we can support the --quiet flag

    q="$([[ $quiet ]] && echo '2>/dev/null' || true)"

    eval jail -e '""' $q            # NUL-delimited

} # jail_info


jail_pop_array () {

#   $1 is the NAME of an associative array to return to the caller.
#   $2 is the NAME of an indexed array of NUL-terminated strings (aka,
#      normal strings) in the form:
#
#           <varname>
#     or
#
#           <varname>=<value>
#
#      where <varname> is the name of the parameter as given by jail(8), 
#      and <value> can be any string of arbitrary characters, except NUL.
#
#   Note that the arguments passed by the caller are CALL-BY-REFERENCE, *not*
#   call-by-value.  The callers associative array "$1" will be set to the 
#   first jail array found in "$2".  Likewise, the array "$2" will have 
#   that jail's entries removed, and will contain only the remaining jails.
#   When the last jail is popped off of "$2", it will be returned as an
#   empty array.
#
#   The caller's indexed array "$2" is an ordered list of strings produced
#   from the output of jail(8), specifically:
#
#       jail -e '"
#
#   A "jail" entry in $2 is represented by one or more consecutive non-empty
#   strings, followed by one empty string (length of 0).
#
#   Because the keys of associative array "$1" are not ordered, one additional 
#   associative key will be added: ["_keys"] will contain a space-separated
#   list of keys, in the same order as jail(8) provided them to us.
#
#   A successful return value means one jail was popped off and returned in
#   "$1".  A failed return value means that "$2" was passed to us as an
#   empty array, and no jail is returned in "$1"
#
#   THE CALLER MUST declare $1 associative PRIOR to calling us.

local -n jpop="$1" jailstack="$2"
local ind elem var val

    for var in ${!jpop[@]}      # For each array key value in jpop, ...
    do
        unset jpop["$var"]      # ... clear each array element.
    done

# Initialize a list of the keys in the order they were added.

    jpop["_keys"]=

    unset ind                       # Unset ind, just to be explicit.

    for ind in ${!jailstack[@]}     # For each (numeric) index in jailstack (if any),
    do

        elem="${jailstack[ind]}"    # Take the value of that element,
        unset jailstack[$ind]       #   and then unset it.

        [[ "$elem" ]] || break      # "elem" must be non-empty, else that's end-of-jail

        var="${elem%%=*}"           # Variable name is everything left of '='
        val="${elem#$var}"          # val is everything except the variable name
        val="${val#=}"              # Strip leading '=' off of val, if present

        jpop["_keys"]+="$var "      # Append the variable name to the ordered list of keys

        jpop["$var"]="$val"         # Store value in associative array

    done

    [[ "$ind" ]]                    # return true if ind is set, i.e., if the
                                    # for loop ran a non-zero number of times.

} # jail_pop_array


jail_print () {

# print the caller's choice of variables from the jail array 
# passed by name in $1

# variables to print are in $2 .. $N

local -n jail
local rc=1 sp v val

    jail="$1"           # $1 is the NAME of an associative jail array

    shift               # $@ is the list of array keys to print

    for v in "${@}"
    do

        if [[ "${jail[$v]@Q}" ]]        # If parameter is set, even an empty string
        then

[[ $debug ]] && printf >&2 'parameter "%s" is %s\n' "${v}" "${jail[$v]@Q}"

            val="${jail[$v]@Q}"         # val is now Bash-quoted (sanitized).
            rc=0                        # This is sufficient to declare success.

            if [[ $vals_only ]]         # If "-n" was specified,
            then

                printf '%s' "$sp" "$val"    # Print optional space and value.
                sp=' '                      # Next time, space is mandatory.

            else            # Otherwise print 'name=value' format:

                printf '%s=%s\n' "$v" "$val"

            fi

        else        # The parameter requested by the user is not present.

            [[ $quiet ]] || printf >&2 'parameter "%s" is unset in jail %s\n' \
                "${v}" "${jail[name]}" 

            if [[ $vals_only ]]
            then
                printf '%s' "$sp" "--"
                sp=' '
            else
                printf 'unset %s\n' "$v"
            fi

        fi

    done

    if [[ $vals_only ]] && [[ $sp ]]
    then
        printf '\n'     # Print a newline if necessary.
    fi

    return $rc

} # jail_print


#==================================================
#
#           M A I N
#
#==================================================


main () {

# If "$list" is set, then $@ are jail names.  If $@
#   is empty, that means list all jail names.
# If "$list" is NOT set, then:
#   "$1" is a jail name, or the literal "all" for all jails.
#   "$2" and beyond are parameter names.  Those parameters
#   will be printed for the jails indicated by $1.  If $2
#   is empty, then all parameters will be printed for the
#   indicated jails.

local rc=1 k jails params j_array one_jail sp jail_found

declare -a jails params

    if [[ "$list" ]]                    # Args represent jail names to
    then                                #   list, *if* they exist.

        jails=( "$@" )                  # Empty array means list ALL jail names.

    else                                # Otherwise, $1 is "all" OR a jail name.

        [[ "${1,,}" == "all" ]] || jails=( "$1" )   # Empty array means all jails
        shift                               # Now "$@" is list of parameters to print.
        params=( "$@" )                     # Empty array means all parameters.

    fi

[[ $debug ]] && echo "${#jails[@]} jail(s) spec'd by user:"
[[ $debug ]] && echo "${jails[@]@A}"

# Check parameter names for unsavory characters:

    k=$'[^A-Za-z0-9._]'     # Fail on any characters outside this class.

    if k="$(egrep $k < <(printf '%s\n' "${params[@]}"))" &&
        [[ $k ]]
    then
        [[ $quiet ]] || 
            sed >&2 's/^/invalid parameter name: /' <<< "$k"
        rc=1
        return $rc
    fi


# Function jail_info (above) returns NUL-delimited lines, one field per line.
# Lines start with <variablename>.  One empty NUL-terminated line indicates
# the end of that jail's output.

    readarray -d "" j_array < <(jail_info) || return
    [[ ${#j_array[@]} -gt 0 ]] || return


# Now:

#   jails is an array of jail names spec'd by the user (possibly empty,
#       meaning all).

#   j_array is array of jail parameters, unfiltered,
#       from jail(8).  Each jail ends with an empty string.

#   params is an array of parameters spec'd by the user, possibly empty.
#       meaning all.

# "one_jail" MUST be declared associative BEFORE calling "jail_pop_array":

    declare -A one_jail

    while jail_pop_array "one_jail" "j_array"   # Pop next jail off j_array into one_jail
    do {

        if [[ ${#jails[@]} -gt 0 ]]     # If jail name(s) are spec'd,
        then                            #   and one_jail[name] is NOT among them:

            if ! egrep -Fqx "${one_jail["name"]}" < <(printf '%s\n' "${jails[@]}")
            then
                continue                    # then skip this one, go on to next jail.
            fi

        fi

        jail_found=1        # Yay, we found at least one of the user's jails.

        if [[ "$list" ]]
        then

            k="name"        # In "--list" mode, this is the only param we print.

            if [[ $vals_only ]]
            then
                printf '%s' "${sp:+$' '}" "${one_jail["$k"]@Q}"
                sp=$'\n'    # Add a newline at the end.
            else
                printf '%s=%s\n' "$k" "${one_jail["$k"]@Q}"
            fi

            rc=0            # We have success.

        else

            if [[ ${#params[@]} -gt 0 ]]    # If specific params were given,
            then
                set -- ${params[@]}         #   then print only those.
            else
                set -- ${one_jail["_keys"]} # Otherwise print all known params.
            fi

            jail_print "one_jail" "$@" && rc=0

        fi

    } done  # while jail_pop_array

    printf '%s' "$sp"       # Print newline if needed.

#[[ $debug ]] && echo "${list@A}"
#[[ $debug ]] && echo "${rc@A}"
#[[ $debug ]] && echo "${quiet@A}"
#[[ $debug ]] && echo "${jail_found@A}"
#[[ $debug ]] && echo "${jails[@]@A}"

    if [[ "$list" ]]
    then
        [[ $rc -gt 0 ]] && [[ ! $quiet ]] && printf >&2 'jail not found: "%s"\n' "${jails[@]}"
    else
        [[ ! $jail_found  ]] && [[ ! $quiet ]] && printf >&2 'jail not found: "%s"\n' "${jails[@]}"
    fi

    return $rc

} # main


[[ $help ]] && { usage; exit 1; }
[[ $list ]] || [ $# -gt 0 ] || { usage; exit 1; }

main "$@"
